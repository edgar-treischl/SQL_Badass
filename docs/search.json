[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Learning SQL the Badass Way",
    "section": "",
    "text": "Learning SQL the badass way is work in progress, keep that in mind if you start reading on these pages.\n\nPreface\nLearning SQL the badass way shows you the basic commands to manage tables and data with SQL. I assume that you are familiar with R (or other programming languages) to manipulate data. For this reason, this page only summarizes main idiosyncrasies of SQL, not concepts that you probably know from any other programming experience.\nI made the experience that learning new things always takes a lot of time and often I have the impression that many courses are designed without taking your personal experience into account. What a surprise, I can read and write some SQL code even I have no idea what SQL does and I guess you can too! This book is the result of this experience and gives a quick and dirty introduction, assuming that you have coding experience and I do not have to explain why we want to wrangle data in the first place.\nIf you do not have this impression or if you want to learn SQL in a proper way, close this book. Go and find your way to a real SQL course or some other resources. However, if you are bored from long introduction what data is, why we need to learn how to wrangle data or other common aspects that come along the data science journey, feel free to join my SQL journey.\nAs we already know, learning SQL is beneficial but maybe we need more motivational input. ChatGTP gives us the following reasons why we should learn SQL even if you are fluent in a language such as R:\n\nEfficient data management: SQL is designed to work with relational databases, which are ideal for managing large amounts of structured data. By learning SQL, R users can efficiently query, retrieve and manage data from databases using SQL commands, making their data analysis tasks more efficient.\nCollaborative work: SQL is a common language used by data analysts and data engineers, making it easier to collaborate and share data between different teams. By learning SQL, R users can communicate more effectively with other data professionals and work collaboratively on projects.\nIntegration with R: R users often work with data that is stored in databases, and SQL provides a way to query and retrieve data from these databases directly into R. This integration allows R users to take advantage of the power of SQL for data management, while still working with their preferred R environment.\nAdvanced data manipulation: SQL provides powerful features for data manipulation, including filtering, sorting, aggregating and joining data from multiple tables. By learning SQL, R users can take advantage of these advanced features to manipulate their data in more sophisticated ways.\nJob market demand: SQL is a widely used skill in the data analytics job market. By learning SQL, R users can broaden their skillset and increase their job market competitiveness.\n\nIn addition, ChatGTP also helps us to get an overview about the most important R packages that are commonly used for working with SQL, including:\n\ndplyr: A powerful package for data manipulation that can connect to various SQL databases and perform operations such as filtering, grouping, and joining (Wickham et al. 2023).\nDBI: An R package that provides a common interface for connecting to various SQL databases (, Wickham, and Müller 2022).\nRMySQL and RSQLite: Packages that provide an interface for connecting to MySQL and SQLite databases, respectively (Ooms et al. 2022; Müller et al. 2023).\nRJDBC: A package that provides a JDBC interface for connecting to various databases, including Oracle, Microsoft SQL Server, and PostgreSQL (Urbanek 2022).\nRODBC: A package that provides an ODBC interface for connecting to various databases, including Microsoft SQL Server and PostgreSQL (Ripley and Lapsley 2022).\nsqldf: A package that allows you to run SQL queries on data frames in R (Grothendieck 2017).\n\nOverall, the choice of which package to use will depend on the specific database you’re working with and your preferred interface. However, these packages should provide a good starting point for working with SQL in R, but first we need to outline some SQL basics.\n\n\n\n\nGrothendieck, G. 2017. “Sqldf: Manipulate r Data Frames Using SQL.” https://CRAN.R-project.org/package=sqldf.\n\n\nMüller, Kirill, Hadley Wickham, David A. James, and Seth Falcon. 2023. “RSQLite: SQLite Interface for r.” https://CRAN.R-project.org/package=RSQLite.\n\n\nOoms, Jeroen, David James, Saikat DebRoy, Hadley Wickham, and Jeffrey Horner. 2022. “RMySQL: Database Interface and ’MySQL’ Driver for r.” https://CRAN.R-project.org/package=RMySQL.\n\n\nR Special Interest Group on Databases (R-SIG-DB), Hadley Wickham, and Kirill Müller. 2022. “DBI: R Database Interface.” https://CRAN.R-project.org/package=DBI.\n\n\nRipley, Brian, and Michael Lapsley. 2022. “RODBC: ODBC Database Access.” https://CRAN.R-project.org/package=RODBC.\n\n\nUrbanek, Simon. 2022. “RJDBC: Provides Access to Databases Through the JDBC Interface.” https://CRAN.R-project.org/package=RJDBC.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis Vaughan. 2023. “Dplyr: A Grammar of Data Manipulation.” https://CRAN.R-project.org/package=dplyr."
  },
  {
    "objectID": "01_intro.html#select",
    "href": "01_intro.html#select",
    "title": "1  Introduction",
    "section": "1.1 Select",
    "text": "1.1 Select\n\nUse select to retrieve a table or a column from a table\nYou can select a single column from a table\nOr select the entire table (data frame) with the wildcard *\n\n\nSELECT * FROM mtcars;\n\n\nDisplaying records 1 - 10\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\n19.2\n6\n167.6\n123\n3.92\n3.440\n18.30\n1\n0\n4\n4\n\n\n\n\n\n\nLimit the output by providing the number of lines\n\n\nSELECT mpg, disp FROM mtcars LIMIT 5;\n\n\n5 records\n\n\nmpg\ndisp\n\n\n\n\n21.0\n160\n\n\n21.0\n160\n\n\n22.8\n108\n\n\n21.4\n258\n\n\n18.7\n360\n\n\n\n\n\n\nYou can also insert a starting point that skips some observations. For instance, OFFSET 10 will skip the first ten table entries\nYou must use quotations marks if the column contains special characters (like 'Petal.Width' from iris data)"
  },
  {
    "objectID": "01_intro.html#where",
    "href": "01_intro.html#where",
    "title": "1  Introduction",
    "section": "1.2 Where",
    "text": "1.2 Where\n\nDefine what you want to select with the Where option (SQL folks say clause)\nFor instance, the variable am is a binary indicator (0/1) and you can use where to select data only if am = 0\n\n\nSELECT * FROM mtcars WHERE am = 0 LIMIT 5;\n\n\n5 records\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n18.7\n8\n360.0\n175\n3.15\n3.440\n17.02\n0\n0\n3\n2\n\n\n18.1\n6\n225.0\n105\n2.76\n3.460\n20.22\n1\n0\n3\n1\n\n\n14.3\n8\n360.0\n245\n3.21\n3.570\n15.84\n0\n0\n3\n4\n\n\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\n\n\n\n\nRemember to use quotation marks if you try to use where with non-numerical values from: e.g. != 'label'\n\n\nSELECT * FROM iris WHERE Species = \"virginica\"  LIMIT 5;\n\n\n5 records\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\n\n\n\n\n6.3\n3.3\n6.0\n2.5\nvirginica\n\n\n5.8\n2.7\n5.1\n1.9\nvirginica\n\n\n7.1\n3.0\n5.9\n2.1\nvirginica\n\n\n6.3\n2.9\n5.6\n1.8\nvirginica\n\n\n6.5\n3.0\n5.8\n2.2\nvirginica"
  },
  {
    "objectID": "01_intro.html#count",
    "href": "01_intro.html#count",
    "title": "1  Introduction",
    "section": "1.3 Count",
    "text": "1.3 Count\n\nCount counts cases!\n\n\nSELECT COUNT(*) FROM mtcars;\n\n\n1 records\n\n\nCOUNT(*)\n\n\n\n\n32\n\n\n\n\n\n\nWe can count subgroups with the WHERE clause:\n\n\nSELECT COUNT(am) FROM mtcars WHERE am != 0;\n\n\n1 records\n\n\nCOUNT(am)\n\n\n\n\n13"
  },
  {
    "objectID": "01_intro.html#distinct",
    "href": "01_intro.html#distinct",
    "title": "1  Introduction",
    "section": "1.4 DISTINCT",
    "text": "1.4 DISTINCT\n\nDistinct can be used to find distinct values. For instance, there are three different Species in the iris data, and distinct helps you to distract them:\n\n\nSELECT DISTINCT Species FROM iris\n\n\n3 records\n\n\nSpecies\n\n\n\n\nsetosa\n\n\nversicolor\n\n\nvirginica\n\n\n\n\n\n\nAs in other programming languages, we can combine several commands. For instance, we can COUNT how many Distinct species the iris data has:\n\n\nSELECT COUNT (DISTINCT Species) FROM iris\n\n\n1 records\n\n\nCOUNT (DISTINCT Species)\n\n\n\n\n3"
  },
  {
    "objectID": "01_intro.html#insert-values",
    "href": "01_intro.html#insert-values",
    "title": "1  Introduction",
    "section": "1.5 Insert Values",
    "text": "1.5 Insert Values\n\nNext, I use a small data set (df) to illustrate how to insert values, make updates, and delete cases\nMy toy data set df has two observations with three variables: x,y,z\nNever mind if you do not know what a tribble is, it is just a command to create data\n\n\nlibrary(tidyverse)\n\ndf <- tribble(\n  ~x, ~y,  ~z,\n  \"a\", 2,  3.6,\n  \"b\", 1,  8.5\n)\ndf\n\n# A tibble: 2 × 3\n  x         y     z\n  <chr> <dbl> <dbl>\n1 a         2   3.6\n2 b         1   8.5\n\n\n\nNow, we can insert new values into df by providing a list of the columns you want to fill in with values for each column:\n\n\nINSERT INTO df (x, y, z) VALUES('c', 3, 1);\n\nLet’s see whether it worked:\n\nSELECT * FROM df;\n\n\n3 records\n\n\nx\ny\nz\n\n\n\n\na\n2\n3.6\n\n\nb\n1\n8.5\n\n\nc\n3\n1.0"
  },
  {
    "objectID": "01_intro.html#updates",
    "href": "01_intro.html#updates",
    "title": "1  Introduction",
    "section": "1.6 Updates",
    "text": "1.6 Updates\n\nMake updates for single (or multiple) values\nFor instance, we can update the variable z and set z = 77 for a certain level of another variable:\n\n\nUPDATE df SET z = 77 WHERE x ='b';\n\n\nTake care, without the WHERE clause all observation would get the new value!\n\n\nSELECT * FROM df;\n\n\n3 records\n\n\nx\ny\nz\n\n\n\n\na\n2\n3.6\n\n\nb\n1\n77.0\n\n\nc\n3\n1.0"
  },
  {
    "objectID": "01_intro.html#delete",
    "href": "01_intro.html#delete",
    "title": "1  Introduction",
    "section": "1.7 Delete",
    "text": "1.7 Delete\n\nWe can drop or delete observations, but of course we should take care since we probably do not want to delete the entire table, just for some implausible values\nFor this reason we use the WHERE clause again, for instance, to get rid of second row of the toy data set:\n\n\nDELETE from df WHERE x = 'b';\n\n\nSELECT * FROM df;\n\n\n2 records\n\n\nx\ny\nz\n\n\n\n\na\n2\n3.6\n\n\nc\n3\n1.0\n\n\n\n\n\nIn summary, in SQL we have to select a table from the database, specify conditions with the where clause. We can use count and distinct to get a first impression of the data. Furthermore, it is all about table. Sometimes we have to insert values, a really vague concept if you are use to work with data, but from a SQL you give your database a update, you are really right in front of the data or imagine that stream of new data needs an update. If that something you have to get used to it, don’t be afraid, me too."
  },
  {
    "objectID": "02_data_management.html#types-of-sql-statements",
    "href": "02_data_management.html#types-of-sql-statements",
    "title": "2  Data management",
    "section": "2.1 Types of SQL Statements",
    "text": "2.1 Types of SQL Statements\nIn the SQL world, we can ultimately distinguish between the data definition and manipulation language:\n\nData Definition Language (DDL):\n\nCommands from the DDL are used to define, change, or drop tables (database)\nExamples: Create, Alter, Truncate, Drop\n\nData Manipulation Language (DML):\n\nDML is used to read and modify data in tables\nThose operations are sometimes named as CRUD operations and we learned them in the last blog: Create, Read, Update, and Delete rows in a table\nExamples: INSERT, SELECT, UPDATE, DELETE\n\n\nLet’s put some of these concepts into practice:"
  },
  {
    "objectID": "02_data_management.html#create",
    "href": "02_data_management.html#create",
    "title": "2  Data management",
    "section": "2.2 CREATE",
    "text": "2.2 CREATE\n\nYou can create new tables with CREATE TABLE. It works in three steps. You have to provide a name for your table, each column needs a name, and you have to specify which kind of information will be stored (e.g. numerical values, characters) in the column\nThe following command creates a toy table (PETSALE) with five variables:\n\n\nCREATE TABLE PETSALE (\n    ID INTEGER NOT NULL,\n    PET CHAR(20),\n    SALEPRICE DECIMAL(6,2),\n    PROFIT DECIMAL(6,2),\n    SALEDATE DATE\n    );\n\nAs the output illustrates, we can add options to create the table:\n\nThe ID variable is an integer that does not accept zero (NOT NULL)\nThe column PET is generated to store a character string\nThe column SALEDATE stores dates\nAnd we can set a primary key with the clause: PRIMARY KEY\nA second example\n\n\nCREATE TABLE PET (\n    ID INTEGER NOT NULL,\n    ANIMAL VARCHAR(20),\n    QUANTITY INTEGER\n    );\n\n\nSo far, both tables do not contain any values. With INSERT INTO, we fill the table with corresponding values:\n\n\nINSERT INTO PETSALE VALUES\n    (1,'Cat',450.09,100.47,'2018-05-29'),\n    (2,'Dog',666.66,150.76,'2018-06-01'),\n    (3,'Parrot',50.00,8.9,'2018-06-04'),\n    (4,'Hamster',60.60,12,'2018-06-11'),\n    (5,'Goldfish',48.48,3.5,'2018-06-14');\n\n\nAnd for the second table:\n\n\nINSERT INTO PET VALUES\n    (1,'Cat',3),\n    (2,'Dog',4),\n    (3,'Hamster',2);\n\nAs we learned in the last session, we can use SELECT to check whether it worked:\n\nSELECT * FROM PET;\n\n\n3 records\n\n\nID\nANIMAL\nQUANTITY\n\n\n\n\n1\nCat\n3\n\n\n2\nDog\n4\n\n\n3\nHamster\n2"
  },
  {
    "objectID": "02_data_management.html#alter-table",
    "href": "02_data_management.html#alter-table",
    "title": "2  Data management",
    "section": "2.3 ALTER TABLE",
    "text": "2.3 ALTER TABLE\n\nWe use the ALTER TABLE statement to add, delete, or modify columns. For instance:\nADD COLUMN, DROP COLUMN; ALTER COLUMN; RENAME COLUMN\n\nFirst: ADD COLUMN\n\nALTER TABLE PETSALE\nADD COLUMN QUANTITY INTEGER;\n\n\nSELECT * FROM PETSALE;\n\n\n5 records\n\n\nID\nPET\nSALEPRICE\nPROFIT\nSALEDATE\nQUANTITY\n\n\n\n\n1\nCat\n450.09\n100.47\n2018-05-29\nNA\n\n\n2\nDog\n666.66\n150.76\n2018-06-01\nNA\n\n\n3\nParrot\n50.00\n8.90\n2018-06-04\nNA\n\n\n4\nHamster\n60.60\n12.00\n2018-06-11\nNA\n\n\n5\nGoldfish\n48.48\n3.50\n2018-06-14\nNA\n\n\n\n\n\n\nNext, fill in some values:\n\n\nUPDATE PETSALE SET QUANTITY = 9 WHERE ID = 1;\n\n\nUPDATE PETSALE SET QUANTITY = 24 WHERE ID = 5;\n\n\nCheck whether it worked:\n\n\nSELECT * FROM PETSALE;\n\n\n5 records\n\n\nID\nPET\nSALEPRICE\nPROFIT\nSALEDATE\nQUANTITY\n\n\n\n\n1\nCat\n450.09\n100.47\n2018-05-29\n9\n\n\n2\nDog\n666.66\n150.76\n2018-06-01\nNA\n\n\n3\nParrot\n50.00\n8.90\n2018-06-04\nNA\n\n\n4\nHamster\n60.60\n12.00\n2018-06-11\nNA\n\n\n5\nGoldfish\n48.48\n3.50\n2018-06-14\n24\n\n\n\n\n\nSecond: DROP COLUMN\n\nALTER TABLE PETSALE\nDROP COLUMN PROFIT;\n\n\nSELECT * FROM PETSALE;\n\n\n5 records\n\n\nID\nPET\nSALEPRICE\nSALEDATE\nQUANTITY\n\n\n\n\n1\nCat\n450.09\n2018-05-29\n9\n\n\n2\nDog\n666.66\n2018-06-01\nNA\n\n\n3\nParrot\n50.00\n2018-06-04\nNA\n\n\n4\nHamster\n60.60\n2018-06-11\nNA\n\n\n5\nGoldfish\n48.48\n2018-06-14\n24\n\n\n\n\n\nThird: ALTER COLUMN\n\nWe can change the data type, for instance, to increase the length of a character variable to VARCHAR(20) with ALTER COLUMN\n\n\nALTER TABLE PETSALE\nALTER COLUMN PET SET DATA TYPE VARCHAR(20);\n\n\nSELECT * FROM PETSALE;\n\n\n5 records\n\n\nID\nPET\nSALEPRICE\nSALEDATE\nQUANTITY\n\n\n\n\n1\nCat\n450.09\n2018-05-29\n9\n\n\n2\nDog\n666.66\n2018-06-01\nNA\n\n\n3\nParrot\n50.00\n2018-06-04\nNA\n\n\n4\nHamster\n60.60\n2018-06-11\nNA\n\n\n5\nGoldfish\n48.48\n2018-06-14\n24\n\n\n\n\n\nForth: RENAME COLUMN\n\nUse RENAME COLUMN to change to a new name:\n\n\nALTER TABLE PETSALE\nRENAME COLUMN PET TO ANIMAL;\n\n\nSELECT * FROM PETSALE;\n\n\n5 records\n\n\nID\nANIMAL\nSALEPRICE\nSALEDATE\nQUANTITY\n\n\n\n\n1\nCat\n450.09\n2018-05-29\n9\n\n\n2\nDog\n666.66\n2018-06-01\nNA\n\n\n3\nParrot\n50.00\n2018-06-04\nNA\n\n\n4\nHamster\n60.60\n2018-06-11\nNA\n\n\n5\nGoldfish\n48.48\n2018-06-14\n24"
  },
  {
    "objectID": "02_data_management.html#truncate",
    "href": "02_data_management.html#truncate",
    "title": "2  Data management",
    "section": "2.4 Truncate",
    "text": "2.4 Truncate\n\nThe TRUNCATE statement will remove all(!) rows from an existing table, just like the one we created in the beginning, however, it does not delete the table itself.\n\n\nTRUNCATE TABLE PET IMMEDIATE;\n\nCaution: DROP TABLE tablename; drops the entire table!\n\nDROP TABLE PETSALE;\n\n\n\n\n\nSchieferdecker, Tobias, Kirill Müller, and Darko Bergant. 2023. “Dm: Relational Data Models.” https://CRAN.R-project.org/package=dm."
  },
  {
    "objectID": "03_calculations.html#string-values-ranges-and-set-of-values",
    "href": "03_calculations.html#string-values-ranges-and-set-of-values",
    "title": "3  Calculations",
    "section": "3.1 String values, ranges and set of values",
    "text": "3.1 String values, ranges and set of values\nWe can use strings and the WHERE clause to search for specific observations. For instance, WHERE countryname LIKE 'A%' means that we search for country name column that start with the corresponding string. And we can use % as a wildcard character:\n\nSELECT * FROM df WHERE country LIKE 'A%';\n\n\n1 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nAustria\n1\n8.5\n2\n\n\n\n\n\nUse a range to select entries that depending on some criteria (> and <). In SQL, we specify WHERE values are between 100 and 200. Keep in mind that values are inclusive within the range. For instance, we can use the mtcars dataset and restrict the table with cars that have a horsepower (hp) between 100 and 200, we can even use an AND to restrict to cars with a manual transmission (AM = 1)\n\nselect * from mtcars\nwhere (hp BETWEEN 100 and 200) and AM = 1 ;\n\n\n5 records\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n30.4\n4\n95.1\n113\n3.77\n1.513\n16.90\n1\n1\n5\n2\n\n\n19.7\n6\n145.0\n175\n3.62\n2.770\n15.50\n0\n1\n5\n6\n\n\n21.4\n4\n121.0\n109\n4.11\n2.780\n18.60\n1\n1\n4\n2\n\n\n\n\n\nAnother option gives us the IN operator. We can select columns by providing a list and the IN operator. As the next example shows, we select only those observations that match the provided list of the IN operator:\n\nSELECT * FROM df WHERE country IN ('Brazil');\n\n\n2 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nBrazil\n4\n2.5\n3\n\n\nBrazil\n3\n3.5\n3\n\n\n\n\n\n\n3.1.1 Sorting Result Sets\nSometimes we need to sort the entries alphabetically and we can do that with the ORDER BY clause. For instance, ORDER BY country:\n\nSELECT * FROM df ORDER BY country;\n\n\n4 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nAustria\n1\n8.5\n2\n\n\nBrazil\n4\n2.5\n3\n\n\nBrazil\n3\n3.5\n3\n\n\nGermany\n2\n3.6\n1\n\n\n\n\n\n\nBy default, the entries are ordered in an ascending order, but we can sort in a descending with DESC option as well:\n\n\nSELECT * FROM df ORDER BY country DESC;\n\n\n4 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nGermany\n2\n3.6\n1\n\n\nBrazil\n4\n2.5\n3\n\n\nBrazil\n3\n3.5\n3\n\n\nAustria\n1\n8.5\n2\n\n\n\n\n\nSometimes we have several observations per unit or any kind of structural order, which is why we may want to order a specific variable. We can sort the data by providing the number of the column we want to use a sort. As the next example shows, we can use y (or 2) to sort the data:\n\nSELECT * FROM df ORDER BY y;\n\n\n4 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nAustria\n1\n8.5\n2\n\n\nGermany\n2\n3.6\n1\n\n\nBrazil\n3\n3.5\n3\n\n\nBrazil\n4\n2.5\n3\n\n\n\n\n\n\n\n3.1.2 Grouping result sets\nTo work with data, we have to get rid of duplicates and often it is much more easier if we restrict result set (data frame). To exclude duplicates we can use the distinct() command, which returns only distinct countries in our example:\n\nSELECT distinct(country) FROM df ;\n\n\n3 records\n\n\ncountry\n\n\n\n\nGermany\n\n\nAustria\n\n\nBrazil\n\n\n\n\n\nIn a similar fashion, maybe we have to clarify how many observations do we have per group? Or in our case, how many entries come from the same country and how often appears each level? In such a case we can count the county column and use the group by clause:\n\nSELECT country, count (country) from df group by country;\n\n\n3 records\n\n\ncountry\ncount (country)\n\n\n\n\nAustria\n1\n\n\nBrazil\n2\n\n\nGermany\n1\n\n\n\n\n\nAs the last output showed, the count functions literally counts, but SQL does not give it a name, it simply displays what it does. We can change this ugly behaviour by providing a variable name and tell SQL how the column should be listed.\n\nSELECT country, count (country) AS Count_Variable from df group by country;\n\n\n3 records\n\n\ncountry\nCount_Variable\n\n\n\n\nAustria\n1\n\n\nBrazil\n2\n\n\nGermany\n1\n\n\n\n\n\nCertainly, counting is not the only function. We can estimate the mean average with AVG(). And now the average, little SQL monkey!\n\nSELECT country, AVG(z) as Mean from df group by country;\n\n\n3 records\n\n\ncountry\nMean\n\n\n\n\nAustria\n8.5\n\n\nBrazil\n3.0\n\n\nGermany\n3.6\n\n\n\n\n\nWe can set a further conditions with a grouped by clause and add the HAVING option. As the next output shows, the group by country HAVING count (country) > 1 returns only countries with more than one observation counted:\n\nSELECT country, count (country) AS Count from df group by country having count (country) > 1;\n\n\n1 records\n\n\ncountry\nCount\n\n\n\n\nBrazil\n2\n\n\n\n\n\nLet us try to remember that the WHEREclause is for entire result set; while HAVING works only for the GROUPED BY clause.\nCongratulations! At this point you are able to:\n\nUse the WHERE clause to refine your query results\nUse the wildcard character (%) as a substitute for unknown characters in a pattern\nUse BETWEEN … AND to specify a range of numbers\nWe can sort query results into ascending or descending order, by using the ORDER BY clause\nAnd we can group query results by using the GROUP BY clause."
  },
  {
    "objectID": "03_calculations.html#built-in-database-functions",
    "href": "03_calculations.html#built-in-database-functions",
    "title": "3  Calculations",
    "section": "3.2 Built-in Database Functions",
    "text": "3.2 Built-in Database Functions\nWe saw in the last section that we can aggregate (count, avg) data and use column functions. Most of the basic statistics functions (sum, avg, min, max) are available and we can specify further conditions, for instance, if we want to summarize groups:\n\nselect sum(mpg) as sum_mpg from mtcars where hp > 100\n\n\n1 records\n\n\nsum_mpg\n\n\n\n\n401.4\n\n\n\n\n\nOr we may use the scalar function and round to the nearest integer:\n\nselect round(drat, 1) as round_drat from mtcars\n\n\nDisplaying records 1 - 10\n\n\nround_drat\n\n\n\n\n3.9\n\n\n3.9\n\n\n3.9\n\n\n3.1\n\n\n3.2\n\n\n2.8\n\n\n3.2\n\n\n3.7\n\n\n3.9\n\n\n3.9\n\n\n\n\n\nIn SQL, there is a class of scalar functions. For instance, we can calculate the length of a string:\n\nselect length(country) from df\n\n\n4 records\n\n\nlength(country)\n\n\n\n\n7\n\n\n7\n\n\n6\n\n\n6\n\n\n\n\n\nDepending the SQL database you use, in db2 you can use the upper (UCASE) and lower case (LCASE) function for strings.\n\nselect upper(country) from df\n\n\n4 records\n\n\nupper(country)\n\n\n\n\nGERMANY\n\n\nAUSTRIA\n\n\nBRAZIL\n\n\nBRAZIL\n\n\n\n\n\nIn case of Oracle the functions are called lower and upper.\n\n3.2.1 Date and Time Built-in Functions\nTalking about SQL databases, there are three different possibilities to work with date and time DB2.\n- Date: YYYYMMDD (Year/Month/Day) - Time: HHMMSS (Hours/Min/Sec) - Timestamp: YYYYMMDDHHMMSSZZZZZZ (Date/Time/Microseconds)\nDepending on what you are up to do, there are functions to extract the day, month, day of month, day of week, day of year, week, hour, minute, and second. You can also extract the current_date and the current_time. Unfortunately, this does not work in Oracle the same way as in DB2, but to give you an example how to extract the day:\n\nselect day(date) from df where country = 'Germany'\n\n\n\n3.2.2 Sub-Queries and Nested Selects\nSub-queries or sub selects are like regular queries but placed within parentheses and nested inside another query. This allows you to form more powerful queries than would have been otherwise possible. An example:\n\nselect avg(mpg) from mtcars\n\n\n1 records\n\n\navg(mpg)\n\n\n\n\n20.09062\n\n\n\n\n\nLet’s say we want to select only the observations with higher values than the average of mpg:\n\nselect * from mtcars where mpg > avg(mpg)\n\nThis would produce the following error: misuse of aggregate function avg() Failed to execute SQL chunk. One of the limitations of built in aggregate functions, like avg(), is that they cannot be evaluated in the WHERE clause always. Thus, we have to use sub-queries.\n\nselect * from mtcars where mpg >\n  (select avg(mpg) from mtcars);\n\n\nDisplaying records 1 - 10\n\n\nmpg\ncyl\ndisp\nhp\ndrat\nwt\nqsec\nvs\nam\ngear\ncarb\n\n\n\n\n21.0\n6\n160.0\n110\n3.90\n2.620\n16.46\n0\n1\n4\n4\n\n\n21.0\n6\n160.0\n110\n3.90\n2.875\n17.02\n0\n1\n4\n4\n\n\n22.8\n4\n108.0\n93\n3.85\n2.320\n18.61\n1\n1\n4\n1\n\n\n21.4\n6\n258.0\n110\n3.08\n3.215\n19.44\n1\n0\n3\n1\n\n\n24.4\n4\n146.7\n62\n3.69\n3.190\n20.00\n1\n0\n4\n2\n\n\n22.8\n4\n140.8\n95\n3.92\n3.150\n22.90\n1\n0\n4\n2\n\n\n32.4\n4\n78.7\n66\n4.08\n2.200\n19.47\n1\n1\n4\n1\n\n\n30.4\n4\n75.7\n52\n4.93\n1.615\n18.52\n1\n1\n4\n2\n\n\n33.9\n4\n71.1\n65\n4.22\n1.835\n19.90\n1\n1\n4\n1\n\n\n21.5\n4\n120.1\n97\n3.70\n2.465\n20.01\n1\n0\n3\n1\n\n\n\n\n\nColum expressions help to set sub queries as a list of columns. Say we select variable Z:\n\nselect country, z from df\n\n\n4 records\n\n\ncountry\nz\n\n\n\n\nGermany\n3.6\n\n\nAustria\n8.5\n\n\nBrazil\n2.5\n\n\nBrazil\n3.5\n\n\n\n\n\nAnd in the next step we add the average of all countries:\n\nselect country, z, avg(z) as avg_Z from df\n\n\n1 records\n\n\ncountry\nz\navg_Z\n\n\n\n\nGermany\n3.6\n4.525\n\n\n\n\n\nThis is obviously wrong. We cannot calculate on micro and macro level the same time, but we could use a sub-query (also called table expressions) to achieve it:\n\nselect country, z, (select avg(z) from df group by country) as avg_Z from df\n\n\n4 records\n\n\ncountry\nz\navg_Z\n\n\n\n\nGermany\n3.6\n8.5\n\n\nAustria\n8.5\n8.5\n\n\nBrazil\n2.5\n8.5\n\n\nBrazil\n3.5\n8.5\n\n\n\n\n\nSub-queries can also be applied in the from clause. They are called derived tables or table expressions, because the outer query uses the results of the sub-query as a data source\n\nselect * from (select hp, vs from mtcars);\n\n\nDisplaying records 1 - 10\n\n\nhp\nvs\n\n\n\n\n110\n0\n\n\n110\n0\n\n\n93\n1\n\n\n110\n1\n\n\n175\n0\n\n\n105\n1\n\n\n245\n0\n\n\n62\n1\n\n\n95\n1\n\n\n123\n1\n\n\n\n\n\n\n\n3.2.3 Working with Multiple Tables\nThere are several ways to access multiple tables in the same query. Namely, using sub-queries, implicit join, and join operators, such as INNER JOIN and OUTER JOIN. For instance:\n\nselect * from df2;\n\n\n2 records\n\n\ncountry\nvalid\nid\n\n\n\n\nGermany\n1\n1\n\n\nAustria\n0\n2\n\n\n\n\n\nLet’s say we want only observations from df that are listed in df2. In such a situation we can use a sub-queries:\n\nselect * from df\n  where country in\n  (select country from df2)\n\n\n2 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nGermany\n2\n3.6\n1\n\n\nAustria\n1\n8.5\n2\n\n\n\n\n\nOf course, you could add also information of the second table and include only countries with a certain value:\n\nselect * from df\n  where country in\n  (select country from df2 where valid = 1)\n\n\n1 records\n\n\ncountry\ny\nz\nid\n\n\n\n\nGermany\n2\n3.6\n1\n\n\n\n\n\nImplicit joins implies that we can access multiple tables by specifying them in the FROM clause of the query. This leads to a CROSS JOIN (also known as Cartesian Join).\n\nselect * from df, df2\n\n\n8 records\n\n\ncountry\ny\nz\nid\ncountry\nvalid\nid\n\n\n\n\nGermany\n2\n3.6\n1\nGermany\n1\n1\n\n\nGermany\n2\n3.6\n1\nAustria\n0\n2\n\n\nAustria\n1\n8.5\n2\nGermany\n1\n1\n\n\nAustria\n1\n8.5\n2\nAustria\n0\n2\n\n\nBrazil\n4\n2.5\n3\nGermany\n1\n1\n\n\nBrazil\n4\n2.5\n3\nAustria\n0\n2\n\n\nBrazil\n3\n3.5\n3\nGermany\n1\n1\n\n\nBrazil\n3\n3.5\n3\nAustria\n0\n2\n\n\n\n\n\nIn DBL2 we can use the where clause to match data (see code); in Oracle there are other matching operaters\n\nselect * from df, df2 where df.id = df.id;\n\nIn case of long names, we can use shorter aliases for table names (or use column names with aliases in the SELECT clause):\n\nselect * from df A, df2 B where A.id = B.id;"
  },
  {
    "objectID": "03_calculations.html#summary",
    "href": "03_calculations.html#summary",
    "title": "3  Calculations",
    "section": "3.3 Summary",
    "text": "3.3 Summary\n\nMost databases come with built-in functions that you can use in SQL statements to perform operations on data within the database itself.\nWhen you work with large datasets, you may save time by using built-in functions rather than first retrieving the data into your application and then executing functions on the retrieved data.\nUse sub-queries to form more powerful queries.\nA sub-select expression helps to evaluate some built-in aggregate functions like the average function.\nDerived tables or table expressions are sub-queries where the outer query uses the results of the sub-query as a data source."
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Grothendieck, G. 2017. “Sqldf: Manipulate r Data Frames Using\nSQL.” https://CRAN.R-project.org/package=sqldf.\n\n\nMüller, Kirill, Hadley Wickham, David A. James, and Seth Falcon. 2023.\n“RSQLite: SQLite Interface for r.” https://CRAN.R-project.org/package=RSQLite.\n\n\nOoms, Jeroen, David James, Saikat DebRoy, Hadley Wickham, and Jeffrey\nHorner. 2022. “RMySQL: Database Interface and ’MySQL’ Driver for\nr.” https://CRAN.R-project.org/package=RMySQL.\n\n\nR Special Interest Group on Databases (R-SIG-DB), Hadley Wickham, and\nKirill Müller. 2022. “DBI: R Database Interface.” https://CRAN.R-project.org/package=DBI.\n\n\nRipley, Brian, and Michael Lapsley. 2022. “RODBC: ODBC Database\nAccess.” https://CRAN.R-project.org/package=RODBC.\n\n\nSchieferdecker, Tobias, Kirill Müller, and Darko Bergant. 2023.\n“Dm: Relational Data Models.” https://CRAN.R-project.org/package=dm.\n\n\nUrbanek, Simon. 2022. “RJDBC: Provides Access to Databases Through\nthe JDBC Interface.” https://CRAN.R-project.org/package=RJDBC.\n\n\nWickham, Hadley, Romain François, Lionel Henry, Kirill Müller, and Davis\nVaughan. 2023. “Dplyr: A Grammar of Data Manipulation.” https://CRAN.R-project.org/package=dplyr."
  }
]